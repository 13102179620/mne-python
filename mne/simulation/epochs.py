# Authors: Mark Wronkiewicz <wronk.mark@gmail.com>
#          Yousra Bekhti <yousra.bekhti@gmail.com>
#
# License: BSD (3-clause)
from __future__ import division
import copy
import numpy as np

from .. import EpochsArray
from ..io.pick import pick_channels_cov
from ..forward import _apply_forward
from ..utils import check_random_state, _time_mask
from .. import SourceEstimate

# TODO: Add back in linear filter for both epoch and noise generation (like
# in simulate evoked)


def generate_epochs(fwd, stcs, info, cov, events, snr=3, tmin=None, tmax=None,
                    random_state=None):
    """Generate epochs data with noise determined by snr

    Parameters
    ----------
    fwd : dict
        A forward solution
    stcs : SourceEstimate | list of SourceEstimate
        The source time course(s) (as generated by simulation.simulate_stc, for
        example)
    info : dict
        Info dictionary
    cov : Covariance object
        The noise covariance.
    events: array, shape(n_events, 3)
        The events corresponding to stc data
    snr : float | list, len(stc)
        Signal to noise ratio in dB. If list, specify SNR for each epoch trial.
        Here, SNR is defined as:
        10 * log10(var(signal) / var(noise)).
    tmin : float | None
        start of time interval to estimate SNR. If None first time point is
        used.
    tmax : float | None
        start of time interval to estimate SNR. If None last time point
        is used.
    random_state : None | int | np.random.RandomState
        To specify the random generator state.

    Returns
    -------
    epochs : Epochs object
        The simulated data

    See Also
    --------
    mne.simulation.source.generate_sparse_stc
    """
    if type(stcs) == SourceEstimate:
        stcs = [stcs]
    if type(stcs) is not list:
        raise RuntimeError('`stcs` must be SourceEstimate or list of '
                           'SourceEstimate')
    # tmask = _time_mask(stcs[0].times, tmin, tmax)
    for stc in stcs:
        stc.crop(tmin, tmax)

    tmin, tmax = stcs[0].times[0], stcs[0].times[-1]
    sens_data_list = [_apply_forward(fwd, stc, 0, len(stc.times))
                      for stc in stcs]

    sens_data = np.array([stc_info[0] for stc_info in sens_data_list])

    # TODO: check if other default params should be included
    # info['sfreq'] = 1. / np.diff(stc.times)[0]
    epochs = EpochsArray(sens_data, info, events, tmin=tmin)

    # Generate and add in noise for epochs objects
    noise = generate_noise_epochs(epochs, cov, random_state)
    epochs_noised = add_noise_epochs(epochs, noise, snr, tmin=tmin, tmax=tmax)
    return epochs_noised


def generate_noise_epochs(epochs, cov, iir_filter=None, random_state=None):
    """Creates noise as a multivariate Gaussian

    The spatial covariance of the noise is given from the cov matrix.

    Parameters
    ----------
    epochs : mne.epochs
        Epochs object to be used as template
    cov : Covariance object
        The noise covariance
    iir_filter : None | array
        IIR filter coefficients (denominator)
    random_state : None | int | np.random.RandomState
        Random generator state

    Returns
    -------
    noise : epochs object
        An mne.epochs object
    """
    epo_noise = copy.deepcopy(epochs)
    n_channels = np.zeros(epo_noise.info['nchan'])
    n_samples = len(epochs.times)

    noise_cov = pick_channels_cov(cov, include=epo_noise.info['ch_names'])
    c = np.diag(noise_cov.data) if noise_cov['diag'] else noise_cov.data

    # Create epo_noise
    rng = check_random_state(random_state)
    epo_noise.data = rng.multivariate_normal(n_channels, c, n_samples).T

    return epo_noise


def add_noise_epochs(epochs, epo_noise, snr, tmin=None, tmax=None):
    """Adds noise to epochs object with specified SNR(s).

    SNR(s) computed in the interval from tmin to tmax.

    Parameters
    ----------
    epochs : Epochs object
        An instance of epochs signal
    epo_noise : Epochs object
        An instance of epochs object filled purely with noise
    snr : float | len()
        signal to noise ratio in dB. It corresponds to
        10 * log10( var(signal) / var(noise))
    tmin : float
        start time before event
    tmax : float
        end time after event

    Returns
    -------
    epochs_noised : Epochs  object
        An instance of epochs corrupted by noise
    """
    epochs_tmp = copy.deepcopy(epochs)
    noise_tmp = copy.deepcopy(epo_noise)

    tmask = _time_mask(epochs.times, tmin, tmax)
    for ei, (trial_dat, trial_noise) in enumerate(zip(epochs_tmp, noise_tmp)):
        tmp = 10 * np.log10(np.mean((trial_dat[:, tmask] ** 2).ravel()) /
                            np.mean((trial_noise ** 2).ravel()))
        trial_noise = 10 ** ((tmp - snr) / 20) * trial_noise
        epochs_tmp[ei].data = trial_dat + trial_noise

    return epochs_tmp
